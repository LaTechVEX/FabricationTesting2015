#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           InsideMotor,   tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           OutsideMotor,  tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{

//ch1 is right joystick horizontal
//ch2 is right joystick vertical
//ch3 is left joystick horizontal
//ch4 is left joystick vertical
	while(true){
		int vert=vexRT[Ch4];
		int horz=vexRT[Ch3];
		int lMotorPower=vert;
		int rMotorPower=vert;
		int motorNerf=1;

		//If we are pulling left
		if(horz<0){
			//If we are pulling forward
			if(vert>0){
				//If we can't force the right motor to go faster
				if(rMotorPower+abs(horz)>127){
				//Then decrease speed on the left motor
				lMotorPower=127+horz-rMotorPower;
				//And set right to max
				rMotorPower=127;
				}else{
				//Otherwise decrease on left and increase on right
				rMotorPower+=abs(horz);
				lMotorPower+=horz;
				}
			//If we are pulling back
			}else{
				if(rMotorPower+abs(horz)<-127){
				lMotorPower=-127+horz-rMotorPower;
				rMotorPower=-127;
				}else{
				rMotorPower-=abs(horz);
				lMotorPower-=horz;
				}
			}
		//If we are pulling right
		}else{
			//If we are pulling forward
			if(vert>0){
				if(lMotorPower+horz>127){
				rMotorPower=127-horz-lMotorPower;
				lMotorPower=127;
				}else{
				lMotorPower+=horz;
				rMotorPower-=horz;
				}
			//If we are pulling back
			}else{
				if(lMotorPower+abs(horz)<-127){
				rMotorPower=-127+horz-lMotorPower;
				lMotorPower=-127;
				}else{
				lMotorPower-=horz;
				rMotorPower+=horz;
				}
			}
		}

		//Slow motors by 1/4 if btn5D is pressed
		if(vexRT[Btn5D]){
		motorNerf=4;
		}else{
		motorNerf=1;
		}





			//motor[LeftMotor]=lMotorPower/motorNerf;
			//motor[RightMotor]=rMotorPower/motorNerf;

	}
}

int RPMtoPower(int rpm){
	//Equation derived from logarithmic fit line for
	//values obtained from testMotors()
	return pow(1.0000000547282,10000*rpm+49825517);
}







void testMotors(){
	// Variables
	long encnow = 0;
	long encprevious = 0;
	float rpmconversion = 21*((60.0)/392.0);

	// Reset the encoder value to zero
	resetMotorEncoder(InsideMotor);
	SensorValue[I2C_1] = 0;

	// Clear the debug window
	clearDebugStream();

		// Iterate through the different power levels, 1-127
		for(int i = 0; i <= 127; i++)
    {
    	// Set the motor powers
			motor[InsideMotor] = i;
			motor[OutsideMotor] = i;

			// Wait one second and then get the encoder value
			wait(1, seconds);
			encnow = SensorValue[I2C_1];

			// Read the encoder value and output the sensor value and rpm calculation
			writeDebugStreamLine("%d\t%d\t%f", i, encnow, (rpmconversion*encnow));

			// Reset the ticks of the sensor
			SensorValue[I2C_1] = 0;
		}

}
